#!/usr/bin/env python3

#---------------------------------------------------------------
#
# CMPUT 331 Student Submission License
# Version 1.0
# Copyright 2025 <<Insert your name here>>
#
# Redistribution is forbidden in all circumstances. Use of this software
# without explicit authorization from the author is prohibited.
#
# This software was produced as a solution for an assignment in the course
# CMPUT 331 - Computational Cryptography at the University of
# Alberta, Canada. This solution is confidential and remains confidential 
# after it is submitted for grading.
#
# Copying any part of this solution without including this copyright notice
# is illegal.
#
# If any portion of this software is included in a solution submitted for
# grading at an educational institution, the submitter will be subject to
# the sanctions for plagiarism at that institution.
#
# If this software is found in any public website or public repository, the
# person finding it is kindly requested to immediately report, including 
# the URL or other repository locating information, to the following email
# address:
#
#          gkondrak <at> ualberta.ca
#
#---------------------------------------------------------------

"""
CMPUT 331 Assignment 5 Problem 3 Student Solution
January 2025
Author: <Your name here>
"""
import os
import a5p1, a5p2
from sys import flags
import numpy as np
from collections import Counter
from itertools import permutations # Helpful class, see documentation or help(Counter)
ETAOIN = "ETAOINSHRDLCUMWFGYPBVKJXQZ"

def bestFreqDict(text1: str, text2: str) -> dict:
    """
    text1 is a plaintext and text2 is the same text enciphered with an unknown key.

    This function should build off of a modified version of a5p1.freqDict, which tries different combinations
    of decipherments, rather than the original tie-breaking strategy. Return the map when you have found the 
    best accuracy.
    """
   
    cipher_counts = Counter(c.upper() for c in text2 if c.isalpha())
    cipher_freq = {char: count / sum(cipher_counts.values()) for char, count in cipher_counts.items()}
    
    
    freq_groups = {}
    for char, freq in cipher_freq.items():
        if freq in freq_groups:
            freq_groups[freq].append(char)
        else:
            freq_groups[freq] = [char]
    
    
    sorted_freqs = sorted(freq_groups.keys(), reverse=True)
    
   
    base_mapping = {}
    etaoin_idx = 0
    
    for freq in sorted_freqs:
        chars = freq_groups[freq]
        for char in chars:
            if etaoin_idx < len(ETAOIN):
                base_mapping[char] = ETAOIN[etaoin_idx]
                etaoin_idx += 1
    
    
    best_map = base_mapping.copy()
    best_scores = checkEvalDecipherment(best_map, text1, text2)
    
   
    for freq in sorted_freqs:
        chars = freq_groups[freq]
        if len(chars) <= 1:
            continue
            
        
        plain_chars = [base_mapping[c] for c in chars]
        for perm in permutations(plain_chars):
            test_map = base_mapping.copy()
            for i, char in enumerate(chars):
                test_map[char] = perm[i]
                
            scores = checkEvalDecipherment(test_map, text1, text2)
            if sum(scores) > sum(best_scores):
                best_map = test_map.copy()
                best_scores = scores
    
    return best_map
def checkEvalDecipherment(mapping, text1, text2):
    """
    This function should call a5p1.freqDecrypt and a5p2.evalDecipherment to check the key accuracy and 
    decipherment accuracy of a mapping, as done in a5p2.evalDecipherment.

    As in the previous function, text1 is a plaintext and text2 is the same text enciphered. mapping is
    the mapping generated by a freqDict function.
    """
    decrypted_text = a5p1.freqDecrypt(mapping, text2)
    scores = a5p2.evalDecipherment(text1, decrypted_text)
    return scores

def test():
    "Run tests"
    text1 = "If a man is offered a fact which goes against his instincts, he will scrutinize it closely, and unless the evidence is overwhelming, he will refuse to believe it. If, on the other hand, he is offered something which affordz a reason for acting in accordance to his instincts, he will accept it even on the slightest evidence. The origin of myths is explained in this way. -Bertrand Russell"
    text2 = "RU Z NZM RH LUUVIVW Z UZXG DSRXS TLVH ZTZRMHG SRH RMHGRMXGH, SV DROO HXIFGRMRAV RG XOLHVOB, ZMW FMOVHH GSV VERWVMXV RH LEVIDSVONRMT, SV DROO IVUFHV GL YVORVEV RG. RU, LM GSV LGSVI SZMW, SV RH LUUVIVW HLNVGSRMT DSRXS ZUULIWA Z IVZHLM ULI ZXGRMT RM ZXXLIWZMXV GL SRH RMHGRMXGH, SV DROO ZXXVKG RG VEVM LM GSV HORTSGVHG VERWVMXV. GSV LIRTRM LU NBGSH RH VCKOZRMVW RM GSRH DZB. -YVIGIZMW IFHHVOO"
    mapping = bestFreqDict(text1, text2)
    keyacc, decipheracc = checkEvalDecipherment(mapping, text1, text2)
    assert keyacc >= 0.12
    assert decipheracc >= 0.15
if __name__ == '__main__' and not flags.interactive:
    test()
